package com.ye.mydb.backend.vm;

public class VersionManagerImpl implements VersionManager{
    /**
     * 只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：
     * 1.这两个操作是由不同的事务执行的
     * 2.这两个操作操作的是同一个数据项
     * 3.这两个操作至少有一个是更新操作
     *
     * 交换两个互不冲突的操作的顺序，不会对最终的结果造成影响，而交换两个冲突操作的顺序，则是会有影响的。
     */


    /**
     * MVCC
     * DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念
     * 上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。
     * 每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。
     *
     * T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。
     * 假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，
     * 例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。
     *
     * 规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。
     * 规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。
     */


}
